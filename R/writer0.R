#' Write code for shinyFunc.R
#'
#' @rdname wrShFunc
#' @export wrShFunc
#'
wrShFunc <- function() {
  glue::glue(
    'library(Matrix) \n',
    'library(magrittr) \n',
    'library(ggplot2) \n',
    'library(ggrepel) \n',
    'library(hdf5r) \n',
    'library(ggdendro) \n',
    'library(ggpubr) \n',
    'library(grid) \n',
    'library(gridExtra) \n',
    'library(tools) \n',
    '\n',
    '\n',
    '\n',
    '##### Functions for aesthetic control #####\n',
    '# Function to extract legend \n',
    'g_legend <- function(a.gplot){{  \n',
    '  tmp <- ggplot_gtable(ggplot_build(a.gplot))  \n',
    '  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")  \n',
    '  legend <- tmp$grobs[[leg]]  \n',
    '  legend \n',
    '}}\n',
    'ggsav <- function(filename, ...){{  \n',
    '  if(file_ext(filename) == "pdf"){{  \n',
    '    ggsave(filename = filename, useDingbats = FALSE, ...)  \n',
    '  }} else {{  \n',
    '    ggsave(filename = filename, ...)  \n',
    '  }}\n',
    '}}\n',
    '\n',
    '# Plot theme \n',
    'sctheme <- function(base_size = 24, XYval = TRUE, Xang = 0, XjusH = 0.5){{ \n',
    '  oupTheme = theme( \n',
    '    text =             element_text(size = base_size, family = "Helvetica"), \n',
    '    panel.background = element_rect(fill = "white", colour = NA), \n',
    '    axis.line =   element_line(colour = "black"), \n',
    '    axis.ticks =  element_line(colour = "black", size = base_size / 20), \n',
    '    axis.title =  element_text(face = "bold"), \n',
    '    axis.text =   element_text(size = base_size), \n',
    '    axis.text.x = element_text(angle = Xang, hjust = XjusH), \n',
    '    legend.position = "bottom", \n',
    '    legend.key =      element_rect(colour = NA, fill = NA) \n',
    '  ) \n',
    '  if(!XYval){{ \n',
    '    oupTheme = oupTheme + theme( \n',
    '      axis.text.x = element_blank(), axis.ticks.x = element_blank(), \n',
    '      axis.text.y = element_blank(), axis.ticks.y = element_blank()) \n',
    '  }} \n',
    '  return(oupTheme) \n',
    '}} \n',
    '\n',
    '\n',
    '\n',
    '##### Common plotting functions #####\n',
    '# Plot cell information / gene expression on dimred \n',
    'sc2Ddimr <- function(inpConf, inpMeta, inpDimr, inpdr, inp1, \n',
    '                     inpH5, inpGene, inpDtyp, inpsub1, inpsub2, inpmin, inpmax, \n',
    '                     inpsiz, inpord, inpcol, inpfsz, inpasp, inptxt, inplab){{ \n',
    '  # Tidy inputs \n',
    '  inpDtyp = gsub("^Assay: ", "", inpDtyp) \n',
    '  inpH5 = paste0(inpH5, inpDtyp, ".h5") \n',
    '  inpGene = inpGene[[inpDtyp]] \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}} \n',
    '  # Prepare ggData \n',
    '  ggData = data.table(inpDimr[[inpdr]]); colnames(ggData) = c("X","Y")\n',
    '  rat = (max(ggData$X) - min(ggData$X)) / (max(ggData$Y) - min(ggData$Y)) \n',
    '  ggData$sub = inpMeta[, inpConf[UI == inpsub1]$ID, with = FALSE]\n',
    '  if(inpDtyp == "Cell Information"){{\n',
    '    ggData$val = inpMeta[, inpConf[UI == inp1]$ID, with = FALSE]\n',
    '  }} else {{\n',
    '    h5file <- H5File$new(inpH5, mode = "r") \n',
    '    h5data <- h5file[["grp"]][["data"]] \n',
    '    ggData$val = h5data$read(args = list(inpGene[inp1], quote(expr=))) \n',
    '    # ggData[val < 0]$val = 0 \n',
    '    h5file$close_all() \n',
    '  }}\n',
    '  # Split ggData into foreground / background\n',
    '  bgCells = FALSE \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{ \n',
    '    bgCells = TRUE \n',
    '    ggData2 = ggData[!sub %in% inpsub2] \n',
    '    ggData = ggData[sub %in% inpsub2] \n',
    '  }} \n',
    '  # Reorder the cells by value\n',
    '  if(inpord == "Max-1st"){{ \n',
    '    ggData = ggData[order(val)] \n',
    '  }} else if(inpord == "Min-1st"){{ \n',
    '    ggData = ggData[order(-val)] \n',
    '  }} else if(inpord == "Random"){{ \n',
    '    ggData = ggData[sample(nrow(ggData))] \n',
    '  }} \n',
    '  # Do factoring if required \n',
    '  ggCont = TRUE    # Mark is plotted value is continuous\n',
    '  if(inpDtyp == "Cell Information"){{\n',
    '    if(!is.na(inpConf[UI == inp1]$fCL)){{ \n',
    '      ggCol = strsplit(inpConf[UI == inp1]$fCL, "\\\\|")[[1]] \n',
    '      names(ggCol) = levels(ggData$val) \n',
    '      ggLvl = levels(ggData$val)[levels(ggData$val) %in% unique(ggData$val)] \n',
    '      ggData$val = factor(ggData$val, levels = ggLvl) \n',
    '      ggCol = ggCol[ggLvl] \n',
    '      ggCont = FALSE\n',
    '    }} \n',
    '  }}\n',
    '  # Apply min/max.cutoff if required \n',
    '  if(ggCont){{ \n',
    '    min.cutoff = quantile(ggData$val, inpmin/100) \n',
    '    max.cutoff = quantile(ggData$val, inpmax/100) \n',
    '    ggData[val <= min.cutoff]$val = min.cutoff \n',
    '    ggData[val >= max.cutoff]$val = max.cutoff \n',
    '  }}\n',
    '  \n',
    '  # Actual ggplot \n',
    '  ggOut = ggplot(ggData, aes(X, Y, color = val)) \n',
    '  if(bgCells){{ \n',
    '    ggOut = ggOut + \n',
    '      geom_point(data = ggData2, color = "snow2", size = inpsiz, shape = 16) \n',
    '  }} \n',
    '  ggOut = ggOut + \n',
    '    geom_point(size = inpsiz, shape = 16) + \n',
    '    xlab(paste0(inpdr,"1")) + ylab(paste0(inpdr,"2")) + \n',
    '    sctheme(base_size = inpfsz, XYval = inptxt) \n',
    '  if(ggCont){{ \n',
    '    ggOut = ggOut + scale_color_gradientn(paste0(inp1, "  "), colours = inpcol) + \n',
    '      guides(color = guide_colorbar(barwidth = 15)) \n',
    '  }} else {{ \n',
    '    legfsz = min(nchar(paste0(levels(ggData$val), collapse = "")), 200) \n',
    '    legfsz = 0.75 * (inpfsz - (1.5 * floor(legfsz/50))) \n',
    '    ggOut = ggOut + scale_color_manual("", values = ggCol) + \n',
    '      guides(color = guide_legend(override.aes = list(size = 5),  \n',
    '                                  nrow = inpConf[UI == inp1]$fRow)) + \n',
    '      theme(legend.text = element_text(size = legfsz)) \n',
    '    if(inplab){{ \n',
    '      ggData3 = ggData[, .(X = mean(X), Y = mean(Y)), by = "val"] \n',
    '      ggOut = ggOut + \n',
    '        geom_text_repel(data = ggData3, aes(X, Y, label = val), \n',
    '                        color = "grey10", bg.color = "grey95", bg.r = 0.15, \n',
    '                        size = (inpfsz/4), seed = 42) \n',
    '    }} \n',
    '  }} \n',
    '  if(inpasp == "Square") {{ \n',
    '    ggOut = ggOut + coord_fixed(ratio = rat)\n',
    '  }} else if(inpasp == "Fixed") {{ \n',
    '    ggOut = ggOut + coord_fixed() \n',
    '  }} \n',
    '  return(ggOut) \n',
    '}} \n',
    '\n',
    '# Function to get cell numbers \n',
    'sc2Dnum <- function(inpConf, inpMeta, inpDimr, inpdr, inpdrX, inpdrY, inp1, \n',
    '                    inpH5, inpGene, inpDtyp, inpsub1, inpsub2, inpsplt){{ \n',
    '  # Tidy inputs \n',
    '  inpDtyp = gsub("^Assay: ", "", inpDtyp) \n',
    '  inpH5 = paste0(inpH5, inpDtyp, ".h5") \n',
    '  inpGene = inpGene[[inpDtyp]] \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}} \n',
    '  # Prepare ggData \n',
    '  ggData = data.table(inpDimr[[inpdr]]); colnames(ggData) = c("X","Y") \n',
    '  ggData$sub = inpMeta[, inpConf[UI == inpsub1]$ID, with = FALSE] \n',
    '  if(inpDtyp == "Cell Information"){{ \n',
    '    ggData$group = inpMeta[, inpConf[UI == inp1]$ID, with = FALSE] \n',
    '  }} else {{ \n',
    '    h5file <- H5File$new(inpH5, mode = "r") \n',
    '    h5data <- h5file[["grp"]][["data"]] \n',
    '    ggData$group = h5data$read(args = list(inpGene[inp1], quote(expr=))) \n',
    '    h5file$close_all() \n',
    '  }} \n',
    '  # Split ggData into foreground / background \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{ \n',
    '    ggData = ggData[sub %in% inpsub2] \n',
    '  }} \n',
    '  # Split inp1 if necessary \n',
    '  if(length(inpConf[UI == inp1]$fCL) == 0){{ \n',
    '    ggData$group = cut(ggData$group, breaks = round(inpsplt, 0)) \n',
    '  }} else if(is.na(inpConf[UI == inp1]$fCL)){{ \n',
    '    ggData$group = cut(ggData$group, breaks = round(inpsplt, 0)) \n',
    '  }} \n',
    '  # Actual data.table \n',
    '  ggData1 = ggData\n',
    '  if(!is.null(inpdrX[1])){{\n',
    '    ggData1 = ggData1[X > inpdrX[1]][X < inpdrX[2]]\n',
    '    ggData1 = ggData1[Y > inpdrY[1]][Y < inpdrY[2]]\n',
    '  }} \n',
    '  ggData1 = ggData1[, .(nZoom = .N), by = "group"] \n',
    '  ggData = ggData[, .(nCells = .N), by = "group"] \n',
    '  ggData = ggData1[ggData, on = "group"] \n',
    '  ggData = ggData[, c("group", "nCells", "nZoom"), with = FALSE] \n',
    '  ggData[is.na(nZoom)]$nZoom = 0 \n',
    '  ggData$pctZoom = 100 * ggData$nZoom / ggData$nCells \n',
    '  ggData = ggData[order(group)] \n',
    '  return(ggData) \n',
    '}} \n',
    '\n',
    '# Plot X/Y relationship (either confusion matrix or scatter plot) \n',
    'sc2Dcomp <- function(inpConf, inpMeta, inp1, inp2, inpH5, inpGene,  \n',
    '                     inpDtyp1, inpDtyp2, inpsub1, inpsub2,  \n',
    '                     inpmin1, inpmax1, inpmin2, inpmax2, \n',
    '                     inpsiz, inpcol, inpfsz){{  \n',
    '  # Tidy inputs  \n',
    '  inpDtyp1 = gsub("^Assay: ", "", inpDtyp1)  \n',
    '  inpDtyp2 = gsub("^Assay: ", "", inpDtyp2)  \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}}  \n',
    '  # Prepare ggData  \n',
    '  ggData = data.table(sub = inpMeta[, inpConf[UI == inpsub1]$ID, with = FALSE]) \n',
    '  if(inpDtyp1 == "Cell Information"){{ \n',
    '    ggData$val1 = inpMeta[, inpConf[UI == inp1]$ID, with = FALSE] \n',
    '  }} else {{ \n',
    '    h5file <- H5File$new(paste0(inpH5, inpDtyp1, ".h5") , mode = "r")  \n',
    '    h5data <- h5file[["grp"]][["data"]]  \n',
    '    ggData$val1 = h5data$read(args = list(inpGene[[inpDtyp1]][inp1], quote(expr=)))  \n',
    '    h5file$close_all()  \n',
    '  }} \n',
    '  if(inpDtyp2 == "Cell Information"){{ \n',
    '    ggData$val2 = inpMeta[, inpConf[UI == inp2]$ID, with = FALSE] \n',
    '  }} else {{ \n',
    '    h5file <- H5File$new(paste0(inpH5, inpDtyp2, ".h5") , mode = "r")  \n',
    '    h5data <- h5file[["grp"]][["data"]]  \n',
    '    ggData$val2 = h5data$read(args = list(inpGene[[inpDtyp2]][inp2], quote(expr=)))  \n',
    '    h5file$close_all()  \n',
    '  }} \n',
    '  # Split ggData into foreground \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{  \n',
    '    ggData = ggData[sub %in% inpsub2]  \n',
    '  }}  \n',
    '  # Identify continuous covariates and Apply min/max.cutoff if required \n',
    '  ggCont1 = TRUE    # Mark is plotted value is continuous \n',
    '  if(inpDtyp1 == "Cell Information"){{ \n',
    '    if(!is.na(inpConf[UI == inp1]$fCL)){{  \n',
    '      ggCol = strsplit(inpConf[UI == inp1]$fCL, "\\\\|")[[1]]  \n',
    '      names(ggCol) = levels(ggData$val1)  \n',
    '      ggLvl = levels(ggData$val1)[levels(ggData$val1) %in% unique(ggData$val1)]  \n',
    '      ggData$val1 = factor(ggData$val1, levels = ggLvl)  \n',
    '      # ggCol = ggCol[ggLvl]  \n',
    '      ggCont1 = FALSE \n',
    '    }}  \n',
    '  }} \n',
    '  if(ggCont1){{  \n',
    '    min.cutoff1 = quantile(ggData$val1, inpmin1/100) \n',
    '    max.cutoff1 = quantile(ggData$val1, inpmax1/100) \n',
    '    ggData[val1 <= min.cutoff1]$val1 = min.cutoff1 \n',
    '    ggData[val1 >= max.cutoff1]$val1 = max.cutoff1 \n',
    '  }} \n',
    '  # Repeat for inp2 \n',
    '  ggCont2 = TRUE    # Mark is plotted value is continuous \n',
    '  if(inpDtyp2 == "Cell Information"){{ \n',
    '    if(!is.na(inpConf[UI == inp2]$fCL)){{  \n',
    '      ggCol = strsplit(inpConf[UI == inp2]$fCL, "\\\\|")[[1]]  \n',
    '      names(ggCol) = levels(ggData$val2)  \n',
    '      ggLvl = levels(ggData$val2)[levels(ggData$val2) %in% unique(ggData$val2)]  \n',
    '      ggData$val2 = factor(ggData$val2, levels = ggLvl)  \n',
    '      # ggCol = ggCol[ggLvl]  \n',
    '      ggCont2 = FALSE \n',
    '    }}  \n',
    '  }} \n',
    '  if(ggCont2){{  \n',
    '    min.cutoff2 = quantile(ggData$val2, inpmin2/100) \n',
    '    max.cutoff2 = quantile(ggData$val2, inpmax2/100) \n',
    '    ggData[val2 <= min.cutoff2]$val2 = min.cutoff2 \n',
    '    ggData[val2 >= max.cutoff2]$val2 = max.cutoff2 \n',
    '  }} \n',
    '   \n',
    '  # Start ggplot \n',
    '  if(ggCont1 == TRUE & ggCont2 == TRUE){{ \n',
    '    # Both cont: Scatter plot \n',
    '    ggOut <- ggplot(ggData, aes(val1, val2)) +  \n',
    '      geom_point() + sctheme(base_size = inpfsz) + xlab(inp1) + ylab(inp2) \n',
    '  }} else if(ggCont1 == FALSE & ggCont2 == FALSE){{ \n',
    '    # Both cate: Confusion matrix \n',
    '    allCombi <- CJ(val1 = unique(ggData$val1), val2 = unique(ggData$val2)) \n',
    '    ggData <- ggData[, .N, by = .(val1, val2)] \n',
    '    ggData <- merge(allCombi, ggData, by = c("val1", "val2"), all.x = TRUE) \n',
    '    ggData[is.na(N), N := 0]  # Replace NA with 0  \n',
    '    ggOut <- ggplot(ggData, aes(val1, val2, fill = N, label = N)) + \n',
    '      geom_tile(color = "white") + geom_text(size = inpfsz/5) +  \n',
    '      scale_fill_gradient(low = "white", high = "steelblue") + \n',
    '      theme_minimal(base_size = inpfsz) + xlab(inp1) + ylab(inp2) +  \n',
    '      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  \n',
    '      ggtitle("Confusion matrix") \n',
    '  }} else {{ \n',
    '    # Cate-cont: Ask user to use VlnBoxP directly! \n',
    '    ggOut <- ggplot() + sctheme(base_size = inpfsz) +  \n',
    '      labs(title = paste0("Please use violin / boxplot to interrogate the data! \\n ", \n',
    '                          "Or refer to `Cell numbers / statistics` tab on the right...")) \n',
    '  }} \n',
    '  return(ggOut) \n',
    '}} \n',
    '\n',
    '# Plot X/Y relationship (either confusion matrix or scatter plot) \n',
    'sc2Dcnum <- function(inpConf, inpMeta, inp1, inp2, inpH5, inpGene,  \n',
    '                     inpDtyp1, inpDtyp2, inpsub1, inpsub2,  \n',
    '                     inpmin1, inpmax1, inpmin2, inpmax2, inpcut = 0){{  \n',
    '  # Tidy inputs  \n',
    '  inpDtyp1 = gsub("^Assay: ", "", inpDtyp1)  \n',
    '  inpDtyp2 = gsub("^Assay: ", "", inpDtyp2)  \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}}  \n',
    '  # Prepare ggData  \n',
    '  ggData = data.table(sub = inpMeta[, inpConf[UI == inpsub1]$ID, with = FALSE]) \n',
    '  if(inpDtyp1 == "Cell Information"){{ \n',
    '    ggData$val1 = inpMeta[, inpConf[UI == inp1]$ID, with = FALSE] \n',
    '  }} else {{ \n',
    '    h5file <- H5File$new(paste0(inpH5, inpDtyp1, ".h5") , mode = "r")  \n',
    '    h5data <- h5file[["grp"]][["data"]]  \n',
    '    ggData$val1 = h5data$read(args = list(inpGene[[inpDtyp1]][inp1], quote(expr=)))  \n',
    '    h5file$close_all()  \n',
    '  }} \n',
    '  if(inpDtyp2 == "Cell Information"){{ \n',
    '    ggData$val2 = inpMeta[, inpConf[UI == inp2]$ID, with = FALSE] \n',
    '  }} else {{ \n',
    '    h5file <- H5File$new(paste0(inpH5, inpDtyp2, ".h5") , mode = "r")  \n',
    '    h5data <- h5file[["grp"]][["data"]]  \n',
    '    ggData$val2 = h5data$read(args = list(inpGene[[inpDtyp2]][inp2], quote(expr=)))  \n',
    '    h5file$close_all()  \n',
    '  }} \n',
    '  # Split ggData into foreground \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{  \n',
    '    ggData = ggData[sub %in% inpsub2]  \n',
    '  }}  \n',
    '  # Identify continuous covariates and Apply min/max.cutoff if required \n',
    '  ggCont1 = TRUE    # Mark is plotted value is continuous \n',
    '  if(inpDtyp1 == "Cell Information"){{ \n',
    '    if(!is.na(inpConf[UI == inp1]$fCL)){{  \n',
    '      ggCol = strsplit(inpConf[UI == inp1]$fCL, "\\\\|")[[1]]  \n',
    '      names(ggCol) = levels(ggData$val1)  \n',
    '      ggLvl = levels(ggData$val1)[levels(ggData$val1) %in% unique(ggData$val1)]  \n',
    '      ggData$val1 = factor(ggData$val1, levels = ggLvl)  \n',
    '      # ggCol = ggCol[ggLvl]  \n',
    '      ggCont1 = FALSE \n',
    '    }}  \n',
    '  }} \n',
    '  if(ggCont1){{  \n',
    '    min.cutoff1 = quantile(ggData$val1, inpmin1/100) \n',
    '    max.cutoff1 = quantile(ggData$val1, inpmax1/100) \n',
    '    ggData[val1 <= min.cutoff1]$val1 = min.cutoff1 \n',
    '    ggData[val1 >= max.cutoff1]$val1 = max.cutoff1 \n',
    '  }} \n',
    '  # Repeat for inp2 \n',
    '  ggCont2 = TRUE    # Mark is plotted value is continuous \n',
    '  if(inpDtyp2 == "Cell Information"){{ \n',
    '    if(!is.na(inpConf[UI == inp2]$fCL)){{  \n',
    '      ggCol = strsplit(inpConf[UI == inp2]$fCL, "\\\\|")[[1]]  \n',
    '      names(ggCol) = levels(ggData$val2)  \n',
    '      ggLvl = levels(ggData$val2)[levels(ggData$val2) %in% unique(ggData$val2)]  \n',
    '      ggData$val2 = factor(ggData$val2, levels = ggLvl)  \n',
    '      # ggCol = ggCol[ggLvl]  \n',
    '      ggCont2 = FALSE \n',
    '    }}  \n',
    '  }} \n',
    '  if(ggCont2){{  \n',
    '    min.cutoff2 = quantile(ggData$val2, inpmin2/100) \n',
    '    max.cutoff2 = quantile(ggData$val2, inpmax2/100) \n',
    '    ggData[val2 <= min.cutoff2]$val2 = min.cutoff2 \n',
    '    ggData[val2 >= max.cutoff2]$val2 = max.cutoff2 \n',
    '  }} \n',
    '  \n',
    '  # Actual data.table \n',
    '  if(ggCont1 == TRUE & ggCont2 == TRUE){{ \n',
    '    # Both cont: Pearson / Spearman corr \n',
    '    ggP <- round(cor(ggData$val1, ggData$val2, method = "pearson"), 6) \n',
    '    ggS <- round(cor(ggData$val1, ggData$val2, method = "spearman"), 6) \n',
    '    ggK <- round(cor(ggData$val1, ggData$val2, method = "kendall"), 6) \n',
    '    ggModel <- lm(val2 ~ val1, data = ggData)\n',
    '    ggCoeff <- signif(coef(ggModel), 6)\n',
    '    ggData = data.table(measures = c("Pearson Corr.",\n',
    '                                     "Spearman Corr.",\n',
    '                                     "Kendall Corr.",\n',
    '                                     "LM (Y/RHS~X/LHS) Gradient",\n',
    '                                     "LM (Y/RHS~X/LHS) Intercept"),\n',
    '                        value = c(ggP, ggS, ggK, ggCoeff[2], ggCoeff[1]))\n',
    '    \n',
    '  }} else if(ggCont1 == FALSE & ggCont2 == FALSE){{ \n',
    '    # Both cate: Confusion matrix \n',
    '    ggData <- ggData[, .N, by = .(val1, val2)][order(val1, val2)]\n',
    '    colnames(ggData) <- c("value_left", "value_right", "nCells")\n',
    '    \n',
    '  }} else {{ \n',
    '    # Cate-cont: Ask user to use VlnBoxP directly! \n',
    '    if(ggCont1 == TRUE){{\n',
    '      colnames(ggData) <- c("sub", "val2", "val1")\n',
    '    }} \n',
    '    ggData$express = FALSE \n',
    '    ggData[val2 > inpcut]$express = TRUE \n',
    '    ggData1 = ggData[express == TRUE, .(nExpress = .N), by = "val1"] \n',
    '    ggData = ggData[, .(nCells = .N), by = "val1"] \n',
    '    ggData = ggData1[ggData, on = "val1"] \n',
    '    ggData = ggData[, c("val1", "nCells", "nExpress"), with = FALSE] \n',
    '    ggData[is.na(nExpress)]$nExpress = 0 \n',
    '    ggData$pctExpress = round(100 * ggData$nExpress / ggData$nCells, 2)\n',
    '    colnames(ggData)[1] = "group"\n',
    '    colnames(ggData)[3] = paste0(colnames(ggData)[3], "_", inp2) \n',
    '    ggData = ggData[order(group)] \n',
    '  }} \n',
    '  return(ggData) \n',
    '}} \n',
    '\n',
    '# Plot gene coexpression on dimred \n',
    'bilinear <- function(x,y,xy,Q11,Q21,Q12,Q22){{ \n',
    '  oup = (xy-x)*(xy-y)*Q11 + x*(xy-y)*Q21 + (xy-x)*y*Q12 + x*y*Q22 \n',
    '  oup = oup / (xy*xy) \n',
    '  return(oup) \n',
    '}} \n',
    'scDRcoex <- function(inpConf, inpMeta, inpDimr, inpdr, inp1, inp2, \n',
    '                     inpH5, inpGene, inpsub1, inpsub2, \n',
    '                     inpmin1, inpmax1, inpmin2, inpmax2, \n',
    '                     inpsiz, inpcol, inpord, inpfsz, inpasp, inptxt){{ \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}} \n',
    '  # Prepare ggData \n',
    '  ggData = data.table(inpDimr[[inpdr]]); colnames(ggData) = c("X","Y") \n',
    '  rat = (max(ggData$X) - min(ggData$X)) / (max(ggData$Y) - min(ggData$Y)) \n',
    '  ggData$sub = inpMeta[, inpConf[UI == inpsub1]$ID, with = FALSE] \n',
    '  h5file <- H5File$new(inpH5, mode = "r") \n',
    '  h5data <- h5file[["grp"]][["data"]] \n',
    '  ggData$val1 = h5data$read(args = list(inpGene[inp1], quote(expr=))) \n',
    '  ggData[val1 < 0]$val1 = 0 \n',
    '  ggData$val2 = h5data$read(args = list(inpGene[inp2], quote(expr=))) \n',
    '  ggData[val2 < 0]$val2 = 0 \n',
    '  h5file$close_all() \n',
    '  bgCells = FALSE \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{ \n',
    '    bgCells = TRUE \n',
    '    ggData2 = ggData[!sub %in% inpsub2] \n',
    '    ggData = ggData[sub %in% inpsub2] \n',
    '  }} \n',
    '  # Apply min/max.cutoff if required \n',
    '  min.cutoff1 = quantile(ggData$val1, inpmin1/100) \n',
    '  max.cutoff1 = quantile(ggData$val1, inpmax1/100) \n',
    '  ggData[val1 <= min.cutoff1]$val1 = min.cutoff1 \n',
    '  ggData[val1 >= max.cutoff1]$val1 = max.cutoff1 \n',
    '  min.cutoff2 = quantile(ggData$val2, inpmin2/100) \n',
    '  max.cutoff2 = quantile(ggData$val2, inpmax2/100) \n',
    '  ggData[val2 <= min.cutoff1]$val2 = min.cutoff2 \n',
    '  ggData[val2 >= max.cutoff1]$val2 = max.cutoff2 \n',
    '  \n',
    '  # Generate coex color palette \n',
    '  cInp = strsplit(inpcol, "; ")[[1]] \n',
    '  if(cInp[1] == "Red (Gene1)"){{ \n',
    '    c10 = c(255,0,0) \n',
    '  }} else if(cInp[1] == "Orange (Gene1)"){{ \n',
    '    c10 = c(255,140,0) \n',
    '  }} else {{ \n',
    '    c10 = c(0,255,0) \n',
    '  }} \n',
    '  if(cInp[2] == "Green (Gene2)"){{ \n',
    '    c01 = c(0,255,0) \n',
    '  }} else {{ \n',
    '    c01 = c(0,0,255) \n',
    '  }} \n',
    '  c00 = c(217,217,217) ; c11 = c10 + c01 \n',
    '  nGrid = 16; nPad = 2; nTot = nGrid + nPad * 2 \n',
    '  gg = data.table(v1 = rep(0:nTot,nTot+1), v2 = sort(rep(0:nTot,nTot+1))) \n',
    '  gg$vv1 = gg$v1 - nPad ; gg[vv1 < 0]$vv1 = 0; gg[vv1 > nGrid]$vv1 = nGrid \n',
    '  gg$vv2 = gg$v2 - nPad ; gg[vv2 < 0]$vv2 = 0; gg[vv2 > nGrid]$vv2 = nGrid \n',
    '  gg$cR = bilinear(gg$vv1, gg$vv2, nGrid, c00[1], c10[1], c01[1], c11[1]) \n',
    '  gg$cG = bilinear(gg$vv1, gg$vv2, nGrid, c00[2], c10[2], c01[2], c11[2]) \n',
    '  gg$cB = bilinear(gg$vv1, gg$vv2, nGrid, c00[3], c10[3], c01[3], c11[3]) \n',
    '  gg$cMix = rgb(gg$cR, gg$cG, gg$cB, maxColorValue = 255) \n',
    '  gg = gg[, c("v1", "v2", "cMix")] \n',
    '  \n',
    '  # Map colours \n',
    '  ggData$v1 = round(nTot * ggData$val1 / max(ggData$val1)) \n',
    '  ggData$v2 = round(nTot * ggData$val2 / max(ggData$val2)) \n',
    '  ggData$v0 = ggData$v1 + ggData$v2 \n',
    '  ggData = gg[ggData, on = c("v1", "v2")] \n',
    '  if(inpord == "Max-1st"){{ \n',
    '    ggData = ggData[order(v0)] \n',
    '  }} else if(inpord == "Min-1st"){{ \n',
    '    ggData = ggData[order(-v0)] \n',
    '  }} else if(inpord == "Random"){{ \n',
    '    ggData = ggData[sample(nrow(ggData))] \n',
    '  }} \n',
    '  \n',
    '  # Actual ggplot \n',
    '  ggOut = ggplot(ggData, aes(X, Y)) \n',
    '  if(bgCells){{ \n',
    '    ggOut = ggOut + \n',
    '      geom_point(data = ggData2, color = "snow2", size = inpsiz, shape = 16) \n',
    '  }} \n',
    '  ggOut = ggOut + \n',
    '    geom_point(size = inpsiz, shape = 16, color = ggData$cMix) + \n',
    '    xlab(paste0(inpdr,"1")) + ylab(paste0(inpdr,"2")) + \n',
    '    sctheme(base_size = inpfsz, XYval = inptxt) + \n',
    '    guides(color = guide_colorbar(barwidth = 15)) \n',
    '  if(inpasp == "Square") {{ \n',
    '    ggOut = ggOut + coord_fixed(ratio = rat) \n',
    '  }} else if(inpasp == "Fixed") {{ \n',
    '    ggOut = ggOut + coord_fixed() \n',
    '  }} \n',
    '  return(ggOut) \n',
    '}} \n',
    ' \n',
    'scDRcoexLeg <- function(inp1, inp2, inpcol, inpfsz){{ \n',
    '  # Generate coex color palette \n',
    '  cInp = strsplit(inpcol, "; ")[[1]] \n',
    '  if(cInp[1] == "Red (Gene1)"){{ \n',
    '    c10 = c(255,0,0) \n',
    '  }} else if(cInp[1] == "Orange (Gene1)"){{ \n',
    '    c10 = c(255,140,0) \n',
    '  }} else {{ \n',
    '    c10 = c(0,255,0) \n',
    '  }} \n',
    '  if(cInp[2] == "Green (Gene2)"){{ \n',
    '    c01 = c(0,255,0) \n',
    '  }} else {{ \n',
    '    c01 = c(0,0,255) \n',
    '  }} \n',
    '  c00 = c(217,217,217) ; c11 = c10 + c01 \n',
    '  nGrid = 16; nPad = 2; nTot = nGrid + nPad * 2 \n',
    '  gg = data.table(v1 = rep(0:nTot,nTot+1), v2 = sort(rep(0:nTot,nTot+1))) \n',
    '  gg$vv1 = gg$v1 - nPad ; gg[vv1 < 0]$vv1 = 0; gg[vv1 > nGrid]$vv1 = nGrid \n',
    '  gg$vv2 = gg$v2 - nPad ; gg[vv2 < 0]$vv2 = 0; gg[vv2 > nGrid]$vv2 = nGrid \n',
    '  gg$cR = bilinear(gg$vv1, gg$vv2, nGrid, c00[1], c10[1], c01[1], c11[1]) \n',
    '  gg$cG = bilinear(gg$vv1, gg$vv2, nGrid, c00[2], c10[2], c01[2], c11[2]) \n',
    '  gg$cB = bilinear(gg$vv1, gg$vv2, nGrid, c00[3], c10[3], c01[3], c11[3]) \n',
    '  gg$cMix = rgb(gg$cR, gg$cG, gg$cB, maxColorValue = 255) \n',
    '  gg = gg[, c("v1", "v2", "cMix")] \n',
    '  \n',
    '  # Actual ggplot \n',
    '  ggOut = ggplot(gg, aes(v1, v2)) + \n',
    '    geom_tile(fill = gg$cMix) + \n',
    '    xlab(inp1) + ylab(inp2) + coord_fixed(ratio = 1) + \n',
    '    scale_x_continuous(breaks = c(0, nTot), label = c("low", "high")) + \n',
    '    scale_y_continuous(breaks = c(0, nTot), label = c("low", "high")) + \n',
    '    sctheme(base_size = inpfsz, XYval = TRUE) \n',
    '  return(ggOut) \n',
    '}} \n',
    ' \n',
    'scDRcoexNum <- function(inpConf, inpMeta, inp1, inp2, \n',
    '                        inpH5, inpGene, inpsub1, inpsub2){{ \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}} \n',
    '  # Prepare ggData \n',
    '  ggData = inpMeta[, c(inpConf[UI == inpsub1]$ID), with = FALSE] \n',
    '  colnames(ggData) = c("sub") \n',
    '  h5file <- H5File$new(inpH5, mode = "r") \n',
    '  h5data <- h5file[["grp"]][["data"]] \n',
    '  ggData$val1 = h5data$read(args = list(inpGene[inp1], quote(expr=))) \n',
    '  ggData[val1 < 0]$val1 = 0 \n',
    '  ggData$val2 = h5data$read(args = list(inpGene[inp2], quote(expr=))) \n',
    '  ggData[val2 < 0]$val2 = 0 \n',
    '  h5file$close_all() \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{ \n',
    '    ggData = ggData[sub %in% inpsub2] \n',
    '  }} \n',
    '  \n',
    '  # Actual data.table \n',
    '  ggData$express = "none" \n',
    '  ggData[val1 > 0]$express = inp1 \n',
    '  ggData[val2 > 0]$express = inp2 \n',
    '  ggData[val1 > 0 & val2 > 0]$express = "both" \n',
    '  ggData$express = factor(ggData$express, levels = unique(c("both", inp1, inp2, "none"))) \n',
    '  ggData = ggData[, .(nCells = .N), by = "express"] \n',
    '  ggData$percent = 100 * ggData$nCells / sum(ggData$nCells) \n',
    '  ggData = ggData[order(express)] \n',
    '  colnames(ggData)[1] = "expression > 0" \n',
    '  return(ggData) \n',
    '}} \n',
    '\n',
    '# Plot violin / boxplot \n',
    'filter_list <- function(item, fullList, reqLen = 2) {{ \n',
    '  # Filter the item based on the master list \n',
    '  filtered_item <- item[item %in% fullList] \n',
    '  # Return the item only if its length is 2 \n',
    '  if (length(filtered_item) == reqLen) {{ \n',
    '    return(filtered_item) \n',
    '  }} else {{ \n',
    '   return(NULL) # Return NULL if the condition is not met \n',
    '  }} \n',
    '}} \n',
    'scVioBox <- function(inpConf, inpMeta, inp1, inp2, inpH5, inpGene, inpDtyp, \n',
    '                     inpsub1, inpsub2, inptyp, inppts, inpstg, inpstp1, inpstp2, \n',
    '                     inpsiz, inpfsz, inpnoi){{ \n',
    '  # Tidy inputs \n',
    '  inpDtyp = gsub("^Assay: ", "", inpDtyp) \n',
    '  inpH5 = paste0(inpH5, inpDtyp, ".h5") \n', 
    '  inpGene = inpGene[[inpDtyp]] \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}} \n',
    '  # Prepare ggData \n',
    '  ggData = inpMeta[, c(inpConf[UI == inp1]$ID, inpConf[UI == inpsub1]$ID), \n',
    '                   with = FALSE] \n',
    '  colnames(ggData) = c("X", "sub") \n',
    '  \n',
    '  # Load in either cell meta or gene expr\n',
    '  if(inpDtyp == "Cell Information"){{ \n',
    '    ggData$val = inpMeta[[inpConf[UI == inp2]$ID]] \n',
    '  }} else {{ \n',
    '    h5file <- H5File$new(inpH5, mode = "r") \n',
    '    h5data <- h5file[["grp"]][["data"]] \n',
    '    ggData$val = h5data$read(args = list(inpGene[inp2], quote(expr=))) \n',
    '    ggData[val < 0]$val = 0 \n',
    '    if(inpnoi){{ \n',
    '      set.seed(42) \n',
    '      tmpNoise = rnorm(length(ggData$val)) * diff(range(ggData$val)) / 1000 \n',
    '      ggData$val = ggData$val + tmpNoise \n',
    '    }} \n',
    '    h5file$close_all() \n',
    '  }} \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{ \n',
    '    ggData = ggData[sub %in% inpsub2] \n',
    '  }} \n',
    '  \n',
    '  # Do factoring \n',
    '  ggCol = strsplit(inpConf[UI == inp1]$fCL, "\\\\|")[[1]] \n',
    '  names(ggCol) = levels(ggData$X) \n',
    '  ggLvl = levels(ggData$X)[levels(ggData$X) %in% unique(ggData$X)] \n',
    '  ggData$X = factor(ggData$X, levels = ggLvl) \n',
    '  ggCol = ggCol[ggLvl] \n',
    '  \n',
    '  # Actual ggplot \n',
    '  if(inptyp == "violin"){{ \n',
    '    ggOut = ggplot(ggData, aes(X, val, fill = X)) + geom_violin(scale = "width") \n',
    '  }} else {{ \n',
    '    ggOut = ggplot(ggData, aes(X, val, fill = X)) + geom_boxplot() \n',
    '  }} \n',
    '  if(inppts){{ \n',
    '    ggOut = ggOut + geom_jitter(size = inpsiz, shape = 16) \n',
    '  }} \n',
    '  # Add stats test if specified (stg: stats-global, stp: stats-pairwise) \n',
    '  if(inpstg != "none"){{ \n',
    '    ggOut = ggOut + stat_compare_means(size = inpfsz/3, label.x.npc = "centre", method = inpstg) \n',
    '  }} \n',
    '  if(inpstp1 != "none"){{ \n',
    '    compList = strsplit(gsub("\\"|\'| ", "", inpstp2), "\\n")[[1]] \n',
    '    compList = lapply(compList, function(x) {{ \n',
    '      strsplit(x, ",|;")[[1]] \n',
    '    }}) \n',
    '    compList = lapply(compList, filter_list, fullList = ggData$X) \n',
    '    compList = compList[!sapply(compList, is.null)] \n',
    '    if(length(compList) > 0){{ \n',
    '      ggOut = ggOut + stat_compare_means(size = inpfsz/3, method = inpstp1, comparisons = compList) \n',
    '    }} \n',
    '  }} \n',
    '  # Continue ggplot \n',
    '  ggOut = ggOut + xlab(inp1) + ylab(inp2) + \n',
    '    sctheme(base_size = inpfsz, Xang = 45, XjusH = 1) +  \n',
    '    scale_fill_manual("", values = ggCol) +\n',
    '    theme(legend.position = "none")\n',
    '  return(ggOut) \n',
    '}} \n',
    '\n',
    '# Plot proportion plot \n',
    'scProp <- function(inpConf, inpMeta, inp1, inp2, inpsub1, inpsub2, \n',
    '                   inpord1, inpord2, inptyp, inpflp, inpfsz){{ \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}} \n',
    '  # Prepare ggData \n',
    '  ggData = inpMeta[, c(inpConf[UI == inp1]$ID, inpConf[UI == inp2]$ID, \n',
    '                       inpConf[UI == inpsub1]$ID),  \n',
    '                   with = FALSE] \n',
    '  colnames(ggData) = c("X", "grp", "sub") \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{ \n',
    '    ggData = ggData[sub %in% inpsub2] \n',
    '  }} \n',
    '  ggData = ggData[, .(nCells = .N), by = c("X", "grp")] \n',
    '  ggData = ggData[, {{tot = sum(nCells) \n',
    '                      .SD[,.(pctCells = 100 * sum(nCells) / tot, \n',
    '                             nCells = nCells), by = "grp"]}}, by = "X"] \n',
    '  \n',
    '  # Do factoring \n',
    '  ggCol = strsplit(inpConf[UI == inp2]$fCL, "\\\\|")[[1]] \n',
    '  names(ggCol) = levels(ggData$grp) \n',
    '  ggLvl = levels(ggData$grp)[levels(ggData$grp) %in% unique(ggData$grp)] \n',
    '  ggData$grp = factor(ggData$grp, levels = ggLvl) \n',
    '  ggCol = ggCol[ggLvl] \n',
    '  \n',
    '  # Reorder X-axis if required \n',
    '  if(inpord1 != "Original order"){{ \n',
    '    if(inptyp == "Proportion"){{ \n',
    '      ggOrder = ggData[grp == inpord1][order(pctCells)] \n',
    '      if(inpord2 == "Decreasing"){{ggOrder = ggOrder[order(-pctCells)]}} \n',
    '    }} else {{ \n',
    '      ggOrder = ggData[grp == inpord1][order(nCells)] \n',
    '      if(inpord2 == "Decreasing"){{ggOrder = ggOrder[order(-nCells)]}} \n',
    '    }}  \n',
    '    if(inpord2 == "Decreasing"){{ \n',
    '      finalOrder = c(as.character(ggOrder$X), \n',
    '                     setdiff(levels(ggOrder$X), as.character(ggOrder$X))) \n',
    '    }} else {{ \n',
    '      finalOrder = c(setdiff(levels(ggOrder$X), as.character(ggOrder$X)), \n',
    '                     as.character(ggOrder$X)) \n',
    '    }} \n',
    '    ggData$X = factor(ggData$X, levels = finalOrder) \n',
    '    ggLvl = c(setdiff(ggLvl, inpord1), inpord1) \n',
    '    ggData$grp = factor(ggData$grp, levels = ggLvl) \n',
    '  }} \n',
    '  \n',    
    '  # Actual ggplot \n',
    '  if(inptyp == "Proportion"){{ \n',
    '    ggOut = ggplot(ggData, aes(X, pctCells, fill = grp)) + \n',
    '      geom_col() + ylab("Cell Proportion (%)") \n',
    '  }} else {{ \n',
    '    ggOut = ggplot(ggData, aes(X, nCells, fill = grp)) + \n',
    '      geom_col() + ylab("Number of Cells") \n',
    '  }} \n',
    '  if(inpflp){{ \n',
    '    ggOut = ggOut + coord_flip() \n',
    '  }} \n',
    '  ggOut = ggOut + xlab(inp1) + \n',
    '    sctheme(base_size = inpfsz, Xang = 45, XjusH = 1) +  \n',
    '    scale_fill_manual("", values = ggCol) + \n',
    '    theme(legend.position = "right") \n',
    '  return(ggOut) \n',
    '}} \n',
    '\n',  
    '# Get gene list \n',
    'scGeneList <- function(inp, inpGene){{ \n',
    '  geneList = data.table(gene = unique(trimws(strsplit(inp, \',|;|"|\\n\')[[1]])), \n',
    '                        present = TRUE) \n',
    '  geneList[!gene %in% names(inpGene)]$present = FALSE \n',
    '  return(geneList) \n',
    '}} \n',
    '\n',  
    '# Plot gene expression bubbleplot / heatmap \n',
    'scBubbHeat <- function(inpConf, inpMeta, inp, inpGrp, inpPlt, \n',
    '                       inpH5, inpGene, inpsub1, inpsub2, inpScl, inpRow, inpCol, \n',
    '                       inpcols, inpfsz, inpExp, inpMax, save = FALSE){{ \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}} \n',
    '  # Identify genes that are in our dataset \n',
    '  geneList = scGeneList(inp, inpGene) \n',
    '  geneList = geneList[present == TRUE] \n',
    '  shiny::validate(need(nrow(geneList) <= 50, "More than 50 genes to plot! Please reduce the gene list!")) \n',
    '  shiny::validate(need(nrow(geneList) > 1, "Please input at least 2 genes to plot!")) \n',
    '   \n',
    '  # Prepare ggData \n',
    '  h5file <- H5File$new(inpH5, mode = "r") \n',
    '  h5data <- h5file[["grp"]][["data"]] \n',
    '  ggData = data.table() \n',
    '  for(iGene in geneList$gene){{ \n',
    '    tmp = inpMeta[, c("cellID", inpConf[UI == inpsub1]$ID), with = FALSE] \n',
    '    colnames(tmp) = c("cellID", "sub") \n',
    '    tmp$grpBy = inpMeta[[inpConf[UI == inpGrp]$ID]] \n',
    '    tmp$geneName = iGene \n',
    '    tmp$val = h5data$read(args = list(inpGene[iGene], quote(expr=))) \n',
    '    ggData = rbindlist(list(ggData, tmp)) \n',
    '  }} \n',
    '  h5file$close_all() \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{ \n',
    '    ggData = ggData[sub %in% inpsub2] \n',
    '  }} \n',
    '  shiny::validate(need(uniqueN(ggData$grpBy) > 1, "Only 1 group present, unable to plot!")) \n',
    '   \n',
    '  # Aggregate \n',
    '  if(inpExp){{ggData$val = expm1(ggData$val)}} \n',
    '  ggData = ggData[, .(val = mean(val), prop = sum(val>0) / length(cellID)), \n',
    '                  by = c("geneName", "grpBy")] \n',
    '  if(inpExp){{ggData$val = log1p(ggData$val)}} \n',
    '   \n',
    '  # Scale if required \n',
    '  colRange = range(ggData$val) \n',
    '  if(inpScl){{ \n',
    '    ggData[, val:= scale(val), keyby = "geneName"] \n',
    '    ggData[val >  inpMax]$val =  inpMax \n',
    '    ggData[val < -inpMax]$val = -inpMax \n',
    '    colRange = c(-max(abs(range(ggData$val))), max(abs(range(ggData$val)))) \n',
    '  }} \n',
    '   \n',
    '  # hclust row/col if necessary \n',
    '  ggMat = dcast.data.table(ggData, geneName~grpBy, value.var = "val") \n',
    '  tmp = ggMat$geneName \n',
    '  ggMat = as.matrix(ggMat[, -1]) \n',
    '  rownames(ggMat) = tmp \n',
    '  if(inpRow){{ \n',
    '    hcRow = dendro_data(as.dendrogram(hclust(dist(ggMat)))) \n',
    '    ggRow = ggplot() + coord_flip() + \n',
    '      geom_segment(data = hcRow$segments, aes(x=x,y=y,xend=xend,yend=yend)) + \n',
    '      scale_y_continuous(breaks = rep(0, uniqueN(ggData$grpBy)), \n',
    '                         labels = unique(ggData$grpBy), expand = c(0, 0)) + \n',
    '      scale_x_continuous(breaks = seq_along(hcRow$labels$label), \n',
    '                         labels = hcRow$labels$label, expand = c(0, 0.5)) + \n',
    '      sctheme(base_size = inpfsz) + \n',
    '      theme(axis.title = element_blank(), axis.line = element_blank(), \n',
    '            axis.ticks = element_blank(), axis.text.y = element_blank(), \n',
    '            axis.text.x = element_text(color="white", angle = 45, hjust = 1)) \n',
    '    ggData$geneName = factor(ggData$geneName, levels = hcRow$labels$label) \n',
    '  }} else {{ \n',
    '    ggData$geneName = factor(ggData$geneName, levels = rev(geneList$gene)) \n',
    '  }} \n',
    '  if(inpCol){{ \n',
    '    hcCol = dendro_data(as.dendrogram(hclust(dist(t(ggMat))))) \n',
    '    ggCol = ggplot() + \n',
    '      geom_segment(data = hcCol$segments, aes(x=x,y=y,xend=xend,yend=yend)) + \n',
    '      scale_x_continuous(breaks = seq_along(hcCol$labels$label), \n',
    '                         labels = hcCol$labels$label, expand = c(0.05, 0)) + \n',
    '      scale_y_continuous(breaks = rep(0, uniqueN(ggData$geneName)), \n',
    '                         labels = unique(ggData$geneName), expand=c(0,0)) + \n',
    '      sctheme(base_size = inpfsz, Xang = 45, XjusH = 1) + \n',
    '      theme(axis.title = element_blank(), axis.line = element_blank(), \n',
    '            axis.ticks = element_blank(), axis.text.x = element_blank(), \n',
    '            axis.text.y = element_text(color = "white")) \n',
    '    ggData$grpBy = factor(ggData$grpBy, levels = hcCol$labels$label) \n',
    '  }} \n',
    '   \n',
    '  # Actual plot according to plottype \n',
    '  if(inpPlt == "Bubbleplot"){{ \n',
    '    # Bubbleplot \n',
    '    ggOut = ggplot(ggData, aes(grpBy, geneName, color = val, size = prop)) + \n',
    '      geom_point() +  \n',
    '      sctheme(base_size = inpfsz, Xang = 45, XjusH = 1) +  \n',
    '      scale_x_discrete(expand = c(0.05, 0)) +  \n',
    '      scale_y_discrete(expand = c(0, 0.5)) + \n',
    '      scale_size_continuous("proportion", range = c(0, 8), \n',
    '                            limits = c(0, 1), breaks = c(0.00,0.25,0.50,0.75,1.00)) + \n',
    '      scale_color_gradientn("expression", limits = colRange, colours = inpcols) + \n',
    '      guides(color = guide_colorbar(barwidth = 15)) + \n',
    '      theme(axis.title = element_blank(), legend.box = "vertical") \n',
    '  }} else {{ \n',
    '    # Heatmap \n',
    '    ggOut = ggplot(ggData, aes(grpBy, geneName, fill = val)) + \n',
    '      geom_tile() +  \n',
    '      sctheme(base_size = inpfsz, Xang = 45, XjusH = 1) + \n',
    '      scale_x_discrete(expand = c(0.05, 0)) +  \n',
    '      scale_y_discrete(expand = c(0, 0.5)) + \n',
    '      scale_fill_gradientn("expression", limits = colRange, colours = inpcols) + \n',
    '      guides(fill = guide_colorbar(barwidth = 15)) + \n',
    '      theme(axis.title = element_blank()) \n',
    '  }} \n',
    '     \n',
    '  # Final tidy \n',
    '  ggLeg = g_legend(ggOut) \n',
    '  ggOut = ggOut + theme(legend.position = "none") \n',
    '  if(!save){{ \n',
    '    if(inpRow & inpCol){{ggOut =  \n',
    '      grid.arrange(ggOut, ggLeg, ggCol, ggRow, widths = c(7,1), heights = c(1,7,2),  \n',
    '                   layout_matrix = rbind(c(3,NA),c(1,4),c(2,NA)))  \n',
    '    }} else if(inpRow){{ggOut =  \n',
    '      grid.arrange(ggOut, ggLeg, ggRow, widths = c(7,1), heights = c(7,2),  \n',
    '                   layout_matrix = rbind(c(1,3),c(2,NA)))  \n',
    '    }} else if(inpCol){{ggOut =  \n',
    '      grid.arrange(ggOut, ggLeg, ggCol, heights = c(1,7,2),  \n',
    '                   layout_matrix = rbind(c(3),c(1),c(2)))  \n',
    '    }} else {{ggOut =  \n',
    '      grid.arrange(ggOut, ggLeg, heights = c(7,2),  \n',
    '                   layout_matrix = rbind(c(1),c(2)))  \n',
    '    }}  \n',
    '  }} else {{ \n',
    '    if(inpRow & inpCol){{ggOut =  \n',
    '      arrangeGrob(ggOut, ggLeg, ggCol, ggRow, widths = c(7,1), heights = c(1,7,2),  \n',
    '                  layout_matrix = rbind(c(3,NA),c(1,4),c(2,NA)))  \n',
    '    }} else if(inpRow){{ggOut =  \n',
    '      arrangeGrob(ggOut, ggLeg, ggRow, widths = c(7,1), heights = c(7,2),  \n',
    '                  layout_matrix = rbind(c(1,3),c(2,NA)))  \n',
    '    }} else if(inpCol){{ggOut =  \n',
    '      arrangeGrob(ggOut, ggLeg, ggCol, heights = c(1,7,2),  \n',
    '                  layout_matrix = rbind(c(3),c(1),c(2)))  \n',
    '    }} else {{ggOut =  \n',
    '      arrangeGrob(ggOut, ggLeg, heights = c(7,2),  \n',
    '                  layout_matrix = rbind(c(1),c(2)))  \n',
    '    }}  \n',
    '  }} \n',
    '  return(ggOut) \n',
    '}} \n',
    '\n', 
    '# Plot cell information / gene expression on spatial \n',
    'sc2Dspat <- function(inpConf, inpMeta, inpImg, inpAlp, inp1, \n',
    '                     inpH5, inpGene, inpDtyp, inpsub1, inpsub2, inpmin, inpmax, \n',
    '                     inpsiz, inpcol, inpfsz, inplab){{ \n',
    '  # Tidy inputs \n',
    '  inpDtyp = gsub("^Assay: ", "", inpDtyp) \n',
    '  inpH5 = paste0(inpH5, inpDtyp, ".h5") \n',
    '  inpGene = inpGene[[inpDtyp]] \n',
    '  if(is.null(inpsub1)){{inpsub1 = inpConf$UI[1]}} \n',
    '  # Setup image\n',
    '  orgXY = c(0, dim(inpImg[["bg_image"]])[1], 0, dim(inpImg[["bg_image"]])[2]) \n',
    '  orgXY = orgXY / inpImg$lowres \n',
    '  inpImgGrob <- rasterGrob(inpImg[["bg_image"]], interpolate = FALSE, \n',
    '                           width=unit(1,"npc"), height=unit(1,"npc")) \n',
    '  # Prepare ggData \n',
    '  ggData = data.table(inpImg$coord[, c("imagecol", "imagerow")])\n',
    '  colnames(ggData) = c("X","Y")\n',
    '  ggData$Y = orgXY[4] - ggData$Y\n',
    '  ggData$sub = inpMeta[, inpConf[UI == inpsub1]$ID, with = FALSE]\n',
    '  ggData$siz = 1\n',
    '  if(inpDtyp == "Cell Information"){{\n',
    '    ggData$val = inpMeta[, inpConf[UI == inp1]$ID, with = FALSE]\n',
    '  }} else {{\n',
    '    h5file <- H5File$new(inpH5, mode = "r") \n',
    '    h5data <- h5file[["grp"]][["data"]] \n',
    '    ggData$val = h5data$read(args = list(inpGene[inp1], quote(expr=))) \n',
    '    ggData[val < 0]$val = 0 \n',
    '    h5file$close_all() \n',
    '  }}\n',
    '  # Split ggData into foreground / background\n',
    '  bgCells = FALSE \n',
    '  if(length(inpsub2) != 0 & length(inpsub2) != nlevels(ggData$sub)){{ \n',
    '    bgCells = TRUE \n',
    '    ggData2 = ggData[!sub %in% inpsub2] \n',
    '    ggData = ggData[sub %in% inpsub2] \n',
    '  }} \n',
    '  # Do factoring if required \n',
    '  ggCont = TRUE    # Mark is plotted value is continuous\n',
    '  if(inpDtyp == "Cell Information"){{\n',
    '    if(!is.na(inpConf[UI == inp1]$fCL)){{ \n',
    '      ggCol = strsplit(inpConf[UI == inp1]$fCL, "\\\\|")[[1]] \n',
    '      names(ggCol) = levels(ggData$val) \n',
    '      ggLvl = levels(ggData$val)[levels(ggData$val) %in% unique(ggData$val)] \n',
    '      ggData$val = factor(ggData$val, levels = ggLvl) \n',
    '      ggCol = ggCol[ggLvl] \n',
    '      ggCont = FALSE\n',
    '    }} \n',
    '  }}\n',
    '  # Apply min/max.cutoff if required \n',
    '  if(ggCont){{ \n',
    '    min.cutoff = quantile(ggData$val, inpmin/100) \n',
    '    max.cutoff = quantile(ggData$val, inpmax/100) \n',
    '    ggData[val <= min.cutoff]$val = min.cutoff \n',
    '    ggData[val >= max.cutoff]$val = max.cutoff \n',
    '  }}\n',
    '  \n',
    '  # Actual ggplot \n',
    '  if(ggCont){{\n',
    '    ggOut = ggplot(ggData, aes(X, Y, color = val, size = siz, alpha = val)) +\n',
    '      annotation_custom(inpImgGrob, xmin = orgXY[1], xmax = orgXY[2], \n',
    '                                    ymin = orgXY[3], ymax = orgXY[4])\n',
    '  }} else {{\n',
    '    ggOut = ggplot(ggData, aes(X, Y, color = val, size = siz)) +\n',
    '      annotation_custom(inpImgGrob, xmin = orgXY[1], xmax = orgXY[2], \n',
    '                                    ymin = orgXY[3], ymax = orgXY[4])\n',
    '  }}\n',
    '  if(bgCells){{ \n',
    '    ggOut = ggOut + \n',
    '      geom_point(data = ggData2, color = "snow2", size = inpsiz, shape = 16, alpha = inpAlp[1]) \n',
    '  }} \n',
    '  if(ggCont){{ \n',
    '    ggOut = ggOut + \n',
    '      geom_point(shape = 16) + \n',
    '      scale_color_gradientn(paste0(inp1, "  "), colours = inpcol) + \n',
    '      scale_size_continuous(range = c(0, inpsiz), limits = c(0,1)) + \n',
    '      guides(color = guide_colorbar(barwidth = 15),\n',
    '             size = "none", alpha = "none") + scale_alpha(range = inpAlp)\n',
    '  }} else {{ \n',
    '    legfsz = min(nchar(paste0(levels(ggData$val), collapse = "")), 200) \n',
    '    legfsz = 0.75 * (inpfsz - (1.5 * floor(legfsz/50))) \n',
    '    ggOut = ggOut + \n',
    '      geom_point(shape = 16, alpha = inpAlp[2]) + \n',
    '      scale_color_manual("", values = ggCol) + \n',
    '      scale_size_continuous(range = c(0, inpsiz), limits = c(0,1)) + \n',
    '      guides(color = guide_legend(override.aes = list(size = 5),  \n',
    '                                  nrow = inpConf[UI == inp1]$fRow),\n',
    '             size = "none") + \n',
    '      theme(legend.text = element_text(size = legfsz)) \n',
    '    if(inplab){{\n',
    '      ggData3 = ggData[, .(X = mean(X), Y = mean(Y)), by = "val"] \n',
    '      ggOut = ggOut + \n',
    '        geom_text_repel(data = ggData3, aes(X, Y, label = val), \n',
    '                        color = "grey10", bg.color = "grey95", bg.r = 0.15, \n',
    '                        size = (inpfsz/4), seed = 42) \n',
    '    }} \n',
    '  }} \n',
    '  ggOut = ggOut + coord_fixed() + \n',
    '    theme_void(base_size = inpfsz) + theme(\n',
    '      axis.text = element_blank(), axis.line = element_blank(), \n',
    '      legend.position = "bottom", legend.key = element_rect(colour = NA, fill = NA))\n',
    '  return(ggOut) \n',
    '}} \n',
    '\n',   
    '\n',
    '\n'
  )
}

#' Write trackplot code for shinyFunc.R
#'
#' @rdname wrShFuncT1
#' @export wrShFuncT1
#'
wrShFuncT1 <- function() {
  glue::glue(
    '# Trackplot\n',
    'source("./trackplot.R")\n',
    'scTrackplot <- function (\n',
    '    shinyDir, bwColData, geneID, bwInfo, chrID,srt,end,extL,extR, bedFile, gtfFile,\n',
    '    binSize, drawGeneTrack, groupAutoScale, geneTrackH, peakTrackH,\n',
    '    showAxis, geneFsize, trackNamePos, collapseTX, cols) {{\n',
    '  # Check if chr/start/end is not detected OR assign location based on gene\n',
    '  if (is.null(chrID) | is.null(srt) | is.null(end)){{\n',
    '    chrID = bwInfo$chrGene[42]$chr               # failsafe\n',
    '    srt = bwInfo$chrGene[42]$srt\n',
    '    end = bwInfo$chrGene[42]$end\n',
    '  }} else if(!is.null(geneID)){{\n',
    '    chrID = bwInfo$chrGene[gene == geneID]$chr   # gene-based\n',
    '    srt = bwInfo$chrGene[gene == geneID]$srt\n',
    '    end = bwInfo$chrGene[gene == geneID]$end\n',
    '  }} else {{\n',
    '    if(srt > end){{tmp = c(srt, end); srt = tmp[2]; end = tmp[1]}}\n',
    '  }}\n',
    '  # Perform extension and check that location are within chrom.size\n',
    '  srt = as.integer(gsub(",", "", srt)) - as.integer(gsub(",", "", extL))\n',
    '  end = as.integer(gsub(",", "", end)) + as.integer(gsub(",", "", extR))\n',
    '  chrMax = bwInfo$chrSize[chr == chrID]$size\n',
    '  srt <- max(0, min(srt, chrMax))\n',
    '  end <- max(0, min(end, chrMax))\n',
    '  # Tidy bedFile\n',
    '  pk = paste0("./bed_files/", bedFile); pkTrackName = bedFile\n',
    '  if(is.null(bedFile)){{pk = NULL; pkTrackName = NULL}}\n',
    '  # extract track\n',
    '  track_data = track_extract(\n',
    '    colData = bwColData, loci = paste0(chrID, ":", srt, "-", end),\n',
    '    query_ucsc = FALSE, gtf = gtfFile, build = bwInfo$genome)\n',
    '  # plot the tracks\n',
    '  track_plot(\n',
    '    summary_list = track_data, draw_gene_track = drawGeneTrack, #TRUE,\n',
    '    show_ideogram = FALSE, # col = "gray70",\n',
    '    groupAutoScale = groupAutoScale, # groupScaleByCondition = FALSE,\n',
    '    y_max = NULL, y_min = NULL, txname = NULL, genename = NULL,\n',
    '    gene_track_height = geneTrackH, peaks_track_height = peakTrackH, \n',
    '    show_axis = showAxis, gene_fsize = geneFsize, \n',
    '    track_names = NULL, track_names_pos = trackNamePos, regions = NULL,\n',
    '    peaks = pk, peaks_track_names = pkTrackName, \n',
    '    collapse_txs = collapseTX, boxcol = "#192A561A", boxcolalpha = 0.2, \n',
    '    col = cols, layout_ord = c("b", "p", "g")\n',
    '  )\n',
    '}}\n',
    '\n',   
    '\n',
    '\n'
  )
}




